# 事务

## 事务概述

**1、事务处理**（事务操作）：**保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。**

​     例如转账操作：A账户要转账给B账户，那么A账户上减少的钱数和B账户上增加的钱数必须一致，也就是说A账户的转出操作和B账户的转入操作要么全部执行，要么全不执行；如果其中一个操作出现异常而没有执行的话，就会导致账户A和账户B的转入转出金额不一致的情况，为而事实上这种情况是不允许发生的，所以为了防止这种情况的发生，需要使用事务处理。

2、事务的ACID属性：

（1）**原子性（Atomicity）**
	原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 

（2）**一致性（Consistency）**
	事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

（3）**隔离性（Isolation）**
	事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

（4）**持久性（Durability）**
	持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

![1599461002700](_images/1599461002700.png)

## 10.2 开启和结束事务

1、mysql默认是自动提交，执行一句就提交一句。

​	即默认情况下，每一条sql都是一个独立的sql。

2、开启手动提交事务：

（1）set autocommit=false; 

​	接下来所有语句都必须手动提交，否则就不会永久生效

（2）start transaction; 

​	commit; 或 rollback; 此次事务结束 想要事务保证数据安全需要再次进行开启

3、注意：

​	事务的回滚只对DML语句有效，对于DDL语句无效。

## 事务隔离级别

### 事务并发问题

对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:

##### 1、脏读

说明：读到了另一个事务还未提交的数据。

场景：A开启事务，t1时刻修改了数据。B在t2时刻读取了数据并使用，但是A在t3时刻回滚了数据，那么B读取到的数据就是脏数据。

![1](_images/1.png)2、不可重复读

说明：在一次事务操作中，使用相同的查询，却查询到了两个不同的数据。

场景：A开启事务，t1时刻进行了一次查询。B在t2时刻修改并提交了数据，A在t3时刻再次查询数据，会获取与t1时刻不同的数据，这称为不可重复读。

![2](_images/2.png)3、幻读

说明：在一次事务操作中，使用相同的查询，查询到的数据都相同。

场景：A开启事务，t1时刻进行了一次查询。B在t2时刻修改并提交了数据，A在t3时刻再次查询数据，却获取了与t1时刻相同的数据，没有获取到最新的数据，这称为幻读。

![3](_images/3.png)事务隔离级别

**数据库事务的隔离性**：数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。**一个事务与其他事务隔离的程度称为隔离级别。**数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。

**数据库提供的 4 种事务隔离级别：**

| 隔离级别         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| read-uncommitted | 允许A事务读取其他事务未提交和已提交的数据。会出现***脏读、不可重复读、幻读***问题 |
| read-committed   | 只允许A事务读取其他事务已提交的数据。可以避免脏读，但仍然会出现***不可重复读、幻读***问题<br>原理： |
| repeatable-read  | 确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读。但是幻读问题仍然存在。<br/>原理：开启事务时，保存当前快照，根据当前快照做修改。 |
| serializable     | 确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作。所有并发问题都可以避免，但性能十分低下。 |

* Oracle 支持的 2 种事务隔离级别：**READ-COMMITED**, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 。

* Mysql 支持 4 种事务隔离级别。 Mysql 默认的事务隔离级别为: **REPEATABLE-READ**。在mysql中REPEATABLE READ的隔离级别也可以避免幻读了。

    >   若在其他事务修改该字段的过程中，本事务对该字段进行修改，则会进入阻塞状态

### 设置和查看隔离级别

每启动一个 mysql 程序, 就会获得一个单独的数据库连接。每个数据库连接都有一个变量 @@tx_isolation, 表示当前连接的事务隔离级别。mysql服务也有一个全局变量@@global.tx_isolation，表示所有连接的默认事务隔离级别。

* 查看当前mysql连接的隔离级别: 

```
select @@tx_isolation;
```

* 查看全局的隔离级别：

```
select @@global.tx_isolation;
```

* 设置当前 mysql连接的隔离级别:  

```sql
set tx_isolation ='repeatable-read';
```

* 设置数据库系统的全局的隔离级别:

```sql
set global tx_isolation ='read-committed';
```

> 注意：这里的隔离级别中间是减号，不是下划线。
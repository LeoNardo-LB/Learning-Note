# 并发编程简述

## 并发与并行

-   **纯并发**：仍然在单个CPU上运行任务。纯并发系统比顺序系统更快地产生结果，但是它的运行速度不会因为处理器的增加而变得更快。
-   **并发-并行**：使用并发技术，结果程序可以利用更多处理器更快地产生结果。
-   **并行-并发**：使用并行编程技术编写，如果只有一个处理器，结果程序仍然可以运行（Java 8 **Streams**就是一个很好的例子）。
-   **纯并行**：除非有多个处理器，否则不会运行。



## 并发的新定义（目标）

>   **并发性是一系列性能技术，专注于减少等待**

-   这是一个集合：包含许多不同的方法来解决这个问题。这是使定义并发性如此具有挑战性的问题之一，因为技术差异很大。
-   这些是性能技术：就是这样。并发的关键点在于让你的程序运行得更快。在Java中，并发是非常棘手和困难的，所以绝对不要使用它，除非你有一个重大的性能问题 - 即使这样，使用最简单的方法产生你需要的性能，因为并发很快变得无法管理。
-   “减少等待”部分很重要而且微妙。无论（例如）你运行多少个处理器，你只能在等待发生时产生效益。如果你发起I/O请求并立即获得结果，没有延迟，因此无需改进。如果你在多个处理器上运行多个任务，并且每个处理器都以满容量运行，并且没有任务需要等待其他任务，那么尝试提高吞吐量是没有意义的。并发的唯一机会是如果程序的某些部分被迫等待。等待可以以多种形式出现 - 这解释了为什么存在如此不同的并发方法。



## 线程的概念

并发将程序划分成独立分离运行的任务。每个任务都由一个 执行线程 来驱动，我们通常将其简称为 线程 。而一个 线程 就是操作系统进程中单一顺序的控制流。因此，单个进程可以有多个并发执行的任务，但是你的程序使得每个任务都好像有自己的处理器一样。操作系统则从处理器上分配时间片到你程序的所有线程中。

**Thread（线程）** 是将任务关联到处理器的软件概念。虽然创建和使用 Thread 类看起来与任何其他类都很相似，但实际上它们是非常不同的。当你创建一个 Thread 时，JVM 将分配一大块内存到专为线程保留的特殊区域上，用于提供运行任务时所需的一切，包括：

-   程序计数器，指明要执行的下一个 JVM 字节码指令。
-   用于支持 Java 代码执行的栈，包含有关此线程已到达当时执行位置所调用方法的信息。它也包含每个正在执行的方法的所有局部变量(包括原语和堆对象的引用)。每个线程的栈通常在 64K 到 1M 之间 [^1] 。
-   第二个则用于 native code（本机方法栈）执行的栈
-   *thread-local variables* （局部变量表）的存储区域
-   用于控制线程的状态管理变量

包括 `main()` 在内的所有代码都会在某个线程内运行。 每当调用一个方法时，当前程序计数器被推到该线程的栈上，然后栈指针向下移动以足够来创建一个栈帧，其栈帧里存储该方法的所有局部变量，参数和返回值。所有基本类型变量都直接在栈上，虽然方法中创建（或方法中使用）对象的任何引用都位于栈帧中，但对象本身存于堆中。这仅且只有一个堆，被程序中所有线程所共享。

除此以外，线程必须绑定到操作系统，这样它就可以在某个时候连接到处理器。这是作为线程构建过程的一部分为你管理的。Java 使用底层操作系统中的机制来管理线程的执行。



## 小案例：工作窃取线程池

工作窃取线程池简介：工作窃取算法允许已经耗尽输入队列中的工作项的线程从其他队列“窃取”工作项。目标是在处理器之间分配工作项，从而最大限度地利用所有可用的处理器来完成计算密集型任务。这项算法也用于 Java 的fork/join 框架。

```java
import java.util.stream.*;
import java.util.concurrent.*;

class ShowThread implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}

public class WorkStealingPool {
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println(Runtime.getRuntime().availableProcessors());
        // 创建工作窃取线程池
        ExecutorService exec = Executors.newWorkStealingPool();
        // 执行线程
        for (int i = 0; i < 10; i++) {
            exec.execute(new ShowThread());
        }
        exec.awaitTermination(1, TimeUnit.SECONDS);
    }
}
```